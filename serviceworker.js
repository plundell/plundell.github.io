(function(globalScope){

	const ts=(new Date()).getTime();
	function getDurration(){
		let durr=(new Date()).getTime()-ts;
		return "	t = "+durr;
	}
	console.log("Running serviceworker.js..."+(new Date()).toUTCString(),globalScope);

	const config={
		waitForServiceWorkerBoot:false //if true we don't enable navigationPreload
		,primeCacheList:[ //list of urls to fetch and cache on install event
			'/',
			'/index.html',
			'/style.css',
			'/app.js',
		]
	}




	//1. The first event to fire is 'install'. This is where you might create a cache and populate it. It will 
	//   only be called the first time the page is loaded
	globalScope.addEventListener('install',event=>event.waitUntil(onInstall(event)));

	//2. The second event is 'activate'. This is where you might clean up data associated with the previous
	//   version of your service worker. This too will only be called on the first page load, after that the 
	//   service worker will already be active and running in the background
	globalScope.addEventListener('activate',event=>event.waitUntil(onActivate(event)));

	//3. This is called on every subsequent fetch...
	globalScope.addEventListener('fetch',event=>event.respondWith(onFetch(event)));

	

	//When a notification generated by this worker is clicked, show the page
	globalScope.addEventListener('notificationclick',showWindow);

	//Listen to messages from the main page
	globalScope.pageChannel={postMessage:(x)=>console.warn("No channel setup yet.",x)}
	globalScope.addEventListener('message',event=>{
		if(event.data=='REGISTER'){
			globalScope.pageChannel=event.ports[0];
			globalScope.pageChannel.postMessage('REGISTERED');
		}else{
			pageMessageHandler(event.data);
		}
	});

	globalScope.backgroundIntervals={}

	function clearBackgroundInterval(tag){
		if(globalScope.backgroundIntervals[tag]){
			clearTimeout(globalScope.backgroundIntervals[tag])
			delete globalScope.backgroundIntervals[tag]
		}
	}

	const public={
		showNotification:({msg,options,delay})=>{
			setTimeout(()=>{
				try{
					console.log('NOTIFY **background**:',msg);
					options=Object.assign({},options,{tag: 'backgroundNotification',icon:"/favicon.ico"});
					globalScope.registration.showNotification(msg,options);
				}catch(e){
					console.error(e);
				}
			},delay||0)
		}

		,notificationInterval:({tag,msg,options,interval,ttl})=>{
			tag=tag||'default';
			interval=interval||10000;
			ttl=ttl||interval*10;

			clearBackgroundInterval(tag);
			
			globalScope.backgroundIntervals[tag]=setInterval(()=>{
				public.showNotification({msg,options});
			},interval)

			setTimeout(()=>clearBackgroundInterval(tag),ttl);
		}

		,clearAllBackgroundIntervals:()=>{
			Object.values(globalScope.backgroundIntervals).forEach(clearTimeout);
		}
	}





	 













	/**
	 * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event
	 * 
	 * @return void
	 * @async
	 */
	async function onInstall(event){
		try{
			console.log('EVENT: install'+getDurration());

			//If opted preload resources and populate the cache
			try{
				if(Array.isArray(config.primeCacheList) && config.primeCacheList.length){
					console.log("priming cache with the following list of resources:",config.primeCacheList)
					var cache=await caches.open('v1');
					await cache.addAll(config.primeCacheList);
				}else{
					console.warn("Not priming cache")
				}
			}catch(e){
				console.error("Failed to prime cache.",e);
			}
			
		}catch(e){
			console.error(e,config.primeCacheList,cache);
		}
		console.log('FINISHED: install'+getDurration());
		return;
	};

	/**
	 * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event
	 * 
	 * @return void
	 * @async
	 */
	async function onActivate(event){
		try{
			console.log('EVENT: activate'+getDurration());
			
			if(!config.waitForServiceWorkerBoot){
				// If supported, enable navigation preloads. This means that while the service worker is booting up any
				// requests made of it are dispatched directly to the server which in turn implies that we may start a 
				// fetch for a resource which is actually cached, ie. we make the request "just in case"
				if (globalScope.registration.navigationPreload) {
					console.log("allowing server fetching while service worker boots")
					await globalScope.registration.navigationPreload.enable();
				}else{
					console.warn("preloading content is not supported, will wait for service worker boot to finish");
				}
			}else{
				console.warn("waiting for service worker to boot before performing fetching resources")
			}

		}catch(e){
			console.error(e);
		}
		console.log('FINISHED: activate'+getDurration());
		return;
	}


	/**
	 * Intercepts fetch events and returns either a cached or newly fetched response, possibly a 404
	 * 
	 * @param <FetchEvent> event  An extened event with additional properties: .clientId, .preloadResponse, 
	 *                            .replacesCliendId, .resultingClientId, .request and method .respondWith()
	 *                                 https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent
	 * 
	 * @return Promise(<Response>)    Always resolves with a response object
	 * @async
	 */
	async function onFetch(event){
		try{
			var response,src;

			console.log('FETCHING '+event.request.url+getDurration());
			
			
			//First we check the cache
			src="cache";
			response=await caches.match(event.request); 
			if(!response){ 
				//Then we ask the server...
				try{
					//If config.waitForServiceWorkerBoot==false then we enabled navigationPreloading on the 'activate' event
					//which means that the fetch may already have been performed, otherwise we do so now...
					src="server-preload";
					response=await event.preloadResponse; //this resolves with undefined...
					if(!response){
						src="server"
						console.log("Fetching from server now: "+event.request.url+getDurration());
						response=await fetch(event.request);
					}

					// Cache a copy of successfull responses. This happens async and we don't have to wait for it...
					cacheResponse(event.request,response.clone());
					
				}catch(e){
					//The only error which should be thrown here is if the request couldn't be made at 
					//all, eg. a network error. Since we need a response we create one
					response=new Response('Could not perform fetch. Possible network error. See console.', {
						status: 408
						,statusText:"Client error"
						,headers: { 'Content-Type': 'text/plain' }
						,url: event.request.url
					});
					throw e;
				}

			}

			//If we don't have a response now something has gone wrong!
			if(!response){
				throw new Error("BUGBUG: something wrong in code, we should have a response object by now");
			}

		}catch(e){
			console.error(e,getDurration(),{event,response,src});

			response=response|| new Response("Failed to fetch resource, unknown client-side error. See console", {
				status: 500
				,statusText: "Client error"
				,headers: { 'Content-Type': 'text/plain' }
				,url: event.request.url
			});
		}

		console.log(`FINISHED: **${src}** fetch ${event.request.url}`+getDurration(),response);
		return response;
	};







	/**
	 * Store a response to the cache IF it's successful
	 * 
	 * @param object request             The event.request object from fetch-event
	 * @param <Response> clonedResponse  An already cloned response
	 * 
	 * @return void
	 * @async 
	 */
	async function cacheResponse(request,clonedResponse){
		try{
			if(clonedResponse && clonedResponse.status>=200 && clonedResponse.status<300){
				// responses may only be used once, so we store a clone to the cache
				let cache = await caches.open('v1');
				await cache.put(request, clonedResponse);
				console.log("Cached "+request.url+getDurration())
			}else{
				console.warn("Not caching response with status "+clonedResponse.status,clonedResponse);
			}

		}catch(e){
			console.error("Failed to cache response",{request,response:clonedResponse},e);
		}
		return;
		
	}












	async function pageMessageHandler({method,payload,msgId}){
		try{
			if(public.hasOwnProperty(method)){
				console.info("service calling public endpoint: "+method);
				try{
					var response=await public[method](payload);
				}catch(e){
					var err=e;
				}
				globalScope.pageChannel.postMessage({msgId,response,err});
			}else{
				console.error("No such public endpoint:",method,payload,msgId);
			}
		}catch(e){
			console.error(e);
		}
		
	}










	async function subscribeToMessages(){
		try {
			console.log("SUBSCRIBE"+getDurration());
			let options = {}
			let subscription = await self.registration.pushManager.subscribe(options)
			console.log("Subscribed:"+getDurration(),subscription);
		} catch (e) {
			console.error(e);
		}

	}


	
	function showWindow(event){
	  	console.log('Background notification clicked!',event);
	  	setTimeout(()=>event.notification.close(),2000);

	  	// This looks to see if the current is already open and focuses if it is
		event.waitUntil(
		  	clients.matchAll({
			    type: "window"
			})
		  	.then((clientList) => {
		  		console.warn(clientList,clients);
			    for (const client of clientList) {
			    	if (client.url === '/' && 'focus' in client)
			        	return client.focus();
			    }
			    if (clients.openWindow)
			    	return clients.openWindow('/');
			})
		);
	}


})(self)

	




