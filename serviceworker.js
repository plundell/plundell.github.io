(function(globalScope){

	const ts=(new Date()).getTime();
	function getDurration(){
		let durr=(new Date()).getTime()-ts;
		return "	t = "+durr;
	}
	console.log("Running serviceworker.js..."+(new Date()).toUTCString(),globalScope);

	globalScope.config=globalScope.config||{
		waitForServiceWorkerBoot:false //if true we don't enable navigationPreload
		// ,primeCacheList:[ //list of urls to fetch and cache on install event
		// 	'/',
		// 	'/index.html',
		// 	'/style.css',
		// 	'/app.js',
		// ]
		,cacheName:'paragast'
		,database:{
			name:'paragast'
			,stores:[
				{
					name:'notifications'
					,options:{autoIncrement:true}
					,schema:[
						{method:'createIndex',args:["timestamp", "timestamp", { unique: true }]}
					]
				}
				,{
					name:'posts'
					,options:{autoIncrement:true}
				}
				,{
					name:'last'
					,options:{autoIncrement:true}
					,schema:[
						{method:'createIndex',args:["type", "type", { unique: true }]}
					]
				}
			]
		}
		,googleNewsQuery:"https://newsapi.org/v2/top-headlines?sources=techcrunch&apiKey="
		,googleNewsApiKey:'40d9d72d5d1a4505bdbed7dc34fb6cd8'
	}




	//1. The first event to fire is 'install'. This is where you might create a cache and populate it. It will 
	//   only be called the first time the page is loaded
	globalScope.addEventListener('install',event=>event.waitUntil(onInstall(event)));

	//2. The second event is 'activate'. This is where you might clean up data associated with the previous
	//   version of your service worker. This too will only be called on the first page load, after that the 
	//   service worker will already be active and running in the background
	globalScope.addEventListener('activate',event=>event.waitUntil(onActivate(event)));

	//3. This is called on every subsequent fetch...
	globalScope.addEventListener('fetch',event=>event.respondWith(onFetch(event)));

	

	//When a notification generated by this worker is clicked, show the page
	globalScope.addEventListener('notificationclick',showWindow);

	//Listen to messages from the main page
	globalScope.pageChannel={postMessage:(x)=>console.warn("No channel setup yet.",x)}
	globalScope.addEventListener('message',event=>{
		if(event.data=='REGISTER'){
			globalScope.pageChannel=event.ports[0];
			globalScope.pageChannel.postMessage('REGISTERED');
		}else{
			pageMessageHandler(event.data);
		}
	});











	globalScope.backgroundIntervals={}
	function clearBackgroundInterval(tag){
		if(globalScope.backgroundIntervals[tag]){
			clearTimeout(globalScope.backgroundIntervals[tag])
			delete globalScope.backgroundIntervals[tag]
		}
	}




	const public={
		showNotification:({msg,options,delay})=>{
			setTimeout(()=>{
				try{
					console.log('NOTIFY **background**:',msg);
					options=Object.assign({},options,{tag: 'backgroundNotification',icon:"/favicon.ico"});
					globalScope.registration.showNotification(msg,options);
				}catch(e){
					console.error(e);
				}
			},delay||0)
			return;
		}

		,notificationInterval:({tag,msg,options,interval,ttl})=>{
			tag=tag||'default';
			interval=interval||10000;
			ttl=ttl||interval*10;

			clearBackgroundInterval(tag);
			
			var i=1
			globalScope.backgroundIntervals[tag]=setInterval(()=>{
				public.showNotification({msg:msg+" #"+i,options});
				i++;
			},interval)

			setTimeout(()=>clearBackgroundInterval(tag),ttl);
			return;
		}

		,clearBackgroundIntervals:()=>Object.values(globalScope.backgroundIntervals).forEach(clearTimeout)

		,clearCache:()=>caches.delete(globalScope.config.cacheName)

		,setupDatabase:async ()=>{
			try{
				globalScope.db=globalScope.db||await createDatabase(globalScope.config.database.name);
				globalScope.dbStores=globalScope.dbStores||{};
				for(let s of globalScope.config.database.stores){
					if(!globalScope.dbStores.hasOwnProperty(s.name))
						globalScope.dbStores[s.name]=await createObjectStore(s.name,s.options,s.schema);
				}
				console.log("Finished setting up database");
			}catch(e){
				console.error(e);
			}
			return;
		}

		,getAllHeadlines:async ()=>fetchHeadlines()


	}





	 













	/**
	 * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event
	 * 
	 * @return void
	 * @async
	 */
	async function onInstall(event){
		try{
			console.log('EVENT: install'+getDurration());

			//If opted preload resources and populate the cache
			try{
				if(Array.isArray(globalScope.config.primeCacheList) && globalScope.config.primeCacheList.length){
					console.log("priming cache with the following list of resources:",globalScope.config.primeCacheList)
					var cache=await caches.open(globalScope.config.cacheName);
					await cache.addAll(globalScope.config.primeCacheList);
				}else{
					console.warn("Not priming cache")
				}
			}catch(e){
				console.error("Failed to prime cache.",e);
			}
			
		}catch(e){
			console.error(e,globalScope.config.primeCacheList,cache);
		}
		console.log('FINISHED: install'+getDurration());
		return;
	};

	/**
	 * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event
	 * 
	 * @return void
	 * @async
	 */
	async function onActivate(event){
		try{
			console.log('EVENT: activate'+getDurration());
			
			if(!globalScope.config.waitForServiceWorkerBoot){
				// If supported, enable navigation preloads. This means that while the service worker is booting up any
				// requests made of it are dispatched directly to the server which in turn implies that we may start a 
				// fetch for a resource which is actually cached, ie. we make the request "just in case"
				if (globalScope.registration.navigationPreload) {
					console.log("allowing server fetching while service worker boots")
					await globalScope.registration.navigationPreload.enable();
				}else{
					console.warn("preloading content is not supported, will wait for service worker boot to finish");
				}
			}else{
				console.warn("waiting for service worker to boot before performing fetching resources")
			}

		}catch(e){
			console.error(e);
		}
		console.log('FINISHED: activate'+getDurration());
		return;
	}


	/**
	 * Intercepts fetch events and returns either a cached or newly fetched response, possibly a 404
	 * 
	 * @param <FetchEvent> event  An extened event with additional properties: .clientId, .preloadResponse, 
	 *                            .replacesCliendId, .resultingClientId, .request and method .respondWith()
	 *                                 https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent
	 * 
	 * @return Promise(<Response>)    Always resolves with a response object
	 * @async
	 */
	async function onFetch(event){
		try{
			var response,src;

			console.log('FETCHING '+event.request.url+getDurration());
			
			
			//First we check the cache
			src="cache";
			response=await caches.match(event.request); 
			if(!response){ 
				//Then we ask the server...
				try{
					//If globalScope.config.waitForServiceWorkerBoot==false then we enabled navigationPreloading on the 'activate' event
					//which means that the fetch may already have been performed, otherwise we do so now...
					src="server-preload";
					response=await event.preloadResponse; //this resolves with undefined...
					if(!response){
						src="server"
						console.log("Fetching from server now: "+event.request.url+getDurration());
						response=await fetch(event.request);
					}

					// Cache a copy of successfull responses. This happens async and we don't have to wait for it...
					cacheResponse(event.request,response.clone());
					
				}catch(e){
					//The only error which should be thrown here is if the request couldn't be made at 
					//all, eg. a network error. Since we need a response we create one
					response=new Response('Could not perform fetch. Possible network error. See console.', {
						status: 408
						,statusText:"Client error"
						,headers: { 'Content-Type': 'text/plain' }
						,url: event.request.url
					});
					throw e;
				}

			}

			//If we don't have a response now something has gone wrong!
			if(!response){
				throw new Error("BUGBUG: something wrong in code, we should have a response object by now");
			}

		}catch(e){
			console.error(e,getDurration(),{event,response,src});

			response=response|| new Response("Failed to fetch resource, unknown client-side error. See console", {
				status: 500
				,statusText: "Client error"
				,headers: { 'Content-Type': 'text/plain' }
				,url: event.request.url
			});
		}

		console.log(`FINISHED: **${src}** fetch ${event.request.url}`+getDurration(),response);
		return response;
	};







	/**
	 * Store a response to the cache IF it's successful
	 * 
	 * @param object request             The event.request object from fetch-event
	 * @param <Response> clonedResponse  An already cloned response
	 * 
	 * @return void
	 * @async 
	 */
	async function cacheResponse(request,clonedResponse){
		try{
			if(clonedResponse && clonedResponse.status>=200 && clonedResponse.status<300){
				// responses may only be used once, so we store a clone to the cache
				let cache = await caches.open(globalScope.config.cacheName);
				await cache.put(request, clonedResponse);
				console.log("Cached "+request.url+getDurration())
			}else{
				console.warn("Not caching response with status "+clonedResponse.status,clonedResponse);
			}

		}catch(e){
			console.error("Failed to cache response",{request,response:clonedResponse},e);
		}
		return;
		
	}












	async function pageMessageHandler({method,payload,msgId}){
		try{
			if(typeof public[method]=='function'){
				console.info("service calling public endpoint: "+method);
				try{
					var response=await public[method](payload);
				}catch(e){
					var err=e;
				}
				let x={msgId,response,err};
				console.log("service sending response",response)
				globalScope.pageChannel.postMessage(x);
			}else{
				console.error("No such public endpoint:",method,payload,msgId);
			}
		}catch(e){
			console.error(e);
		}
		
	}










	async function subscribeToMessages(){
		try {
			console.log("SUBSCRIBE"+getDurration());
			let options = {}
			let subscription = await self.registration.pushManager.subscribe(options)
			console.log("Subscribed:"+getDurration(),subscription);
		} catch (e) {
			console.error(e);
		}

	}


	
	function showWindow(event){
	  	console.log('Background notification clicked!',event);
	  	setTimeout(()=>event.notification.close(),2000);

	  	// This looks to see if the current is already open and focuses if it is
		event.waitUntil(
		  	clients.matchAll({
			    type: "window"
			})
		  	.then((clientList) => {
		  		console.warn(clientList,clients);
			    for (const client of clientList) {
			    	if (client.url === '/' && 'focus' in client)
			        	return client.focus();
			    }
			    if (clients.openWindow)
			    	return clients.openWindow('/');
			})
		);
	}









	/* IndexedDB */

	//Creates or opens a IDBDatabase...
	function createDatabase(name){
		try{
			console.log(`Creating indexedDB '${name}'`);
			let request = indexedDB.open(name);
			let resolve,reject,promise=new Promise((res,rej)=>{resolve=res;reject=rej;});

			request.onerror=(event)=>{
				console.error(event);
				reject("Failed to open IndexedDB");
			};
			request.onsuccess=(event)=>{
				console.log("Opened IndexedDB",event);
				resolve(event.target.result);
			};

			return promise;
		}catch(e){
			return Promise.reject(e);
		}
	}

	//Creates or opens an IDBObjectStore inside a IDBDatabase
	async function createObjectStore(name,options,schema){
		if(!globalScope.db)
			throw new Error("Database hasn't been setup yet");
		
		console.log(`Creating indexedDB ObjectStore '${name}'`);
		let store=db.createObjectStore(name, options);
		if(schema){
			for(let rule of schema){
				store[rule.method].apply(store,rule.args)
			}
		}
		return Promise((resolve,reject)=>{
			store.transaction.oncomplete=()=>resolve(store);
			store.transaction.onerror=reject;
		});
	}




	function getLast(type){
		return new Date('2022-09-01T10:51:27Z');
	}

	function setLast(type,timestamp){

	}

/*
{
	"status": "ok",
	"totalResults": 7401,
	-"articles": [
		-{
		-"source": {
			"id": null,
			"name": "seattlepi.com"
		},
		"author": "By MATT OTT, AP Business Writer",
		"title": "Fewer Americans file for jobless benefits last week",
		"description": "WASHINGTON (AP) —\nFewer Americans filed for unemployment benefits last week as the labor market continues to shine despite weakening elements of the U.S. economy.\nApplications for jobless aid for the week ending Aug. 27 fell by 5,000 to 232,000, the Labor Dep…",
		"url": "https://www.seattlepi.com/business/article/Fewer-Americans-file-for-jobless-benefits-last-17412312.php",
		"urlToImage": "https://www.seattlepi.com/img/pages/article/opengraph_default.png",
		"publishedAt": "2022-09-01T12:51:27Z",
		"content": "Fewer Americans filed for unemployment benefits last week as the labor market continues to shine despite weakening elements of the U.S. economy.Applications for jobless aid for the week ending Aug. 2… [+2996 chars]"
		},
		-{

*/


	function storeHeadline(headline){
		setLast('headline',headline.publishedAt);

	}

	async function fetchHeadlines(){
		var response=fetch(globalScope.config.googleNewsQuery+globalScope.config.googleNewsApiKey)
		var headlines=response.json().articles;
		for(let headline of headlines){
			delete headline.source;
			headline.publishedAt=Math.floor(new Date(headline.publishedAt)); //unix timestamp
		}
		return headlines;
	}

	async function checkNewHeadlines(){
		let last=getLast('headline');
		let headlines=await getHeadlines();
		for(let headline of headlines){
			if(headline.publishedAt>last){
				storeHeadline(headline);
				public.showNotification(headline.title);
			}
		}

	}



})(self)

	




