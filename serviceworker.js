(function(globalScope){
	

	const ts=(new Date()).getTime();
	function getDurration(){
		let durr=(new Date()).getTime()-ts;
		return "	t = "+durr;
	}

	if(globalScope.started){
		console.warn("serviceworker.js ALREADY RUN at "+globalScope.started,globalScope)
	}else{
		globalScope.started=(new Date()).toUTCString();
		console.warn("running serviceworker.js for first time at "+globalScope.started,globalScope);
	}

	importScripts('/lib.js');



	globalScope.config={
		waitForServiceWorkerBoot:false //if true we don't enable navigationPreload
		,cacheName:'paragast'
		,database:{
			name:'paragast'
			,version:1
			,stores:[
				{
					name:'last'
					,options:{keyPath:'type'}
					,schema:[
						{method:'createIndex',args:["primary-key", "type", { unique: true }]}
					]
				}
				,{
					name:'notifications'
					// ,options:{autoIncrement:true}
					,options:{keyPath:'id'}
					,schema:[
						{method:'createIndex',args:["timestamp", "timestamp", { unique: false }]}
					]
				}
				,{
					name:'headlines'
					,options:{autoIncrement:true}
					,schema:[
						{method:'createIndex',args:["timestamp", "timestamp", { unique: false }]}
					]
				}

			]
		}
		// ,googleNewsQuery:"https://newsapi.org/v2/top-headlines?sources=techcrunch&apiKey="
		,googleNewsQuery:"https://newsapi.org/v2/top-headlines?language=en&pageSize=10&apiKey="
		,googleNewsApiKey:'40d9d72d5d1a4505bdbed7dc34fb6cd8'

		,updateCheckInterval:60*60*1000 //set to 0 to never check
	}




	







	//1. The first event to fire is 'install'. This is where you might create a cache and populate it. It will 
	//   only be called the first time the page is loaded
	globalScope.addEventListener('install',event=>event.waitUntil(onInstall(event)));

	//2. The second event is 'activate'. This is where you might clean up data associated with the previous
	//   version of your service worker. This too will only be called on the first page load, after that the 
	//   service worker will already be active and running in the background
	globalScope.addEventListener('activate',event=>event.waitUntil(onActivate(event)));

	//3. This is called on every subsequent fetch...
	globalScope.addEventListener('fetch',event=>event.respondWith(onFetch(event)));

	

	//When a notification generated by this worker is clicked, show the page
	globalScope.addEventListener('notificationclick',showWindow);




  	//Make enpoints available to main page
	const public={
		clearCache:()=>caches.delete(globalScope.config.cacheName)
		,checkNewHeadlines
		,getAllHeadlines:async ()=>fetchHeadlines() //TODO: change to getting stored headlines as soon as that works
		,deleteDatabase
	}
	globalScope.addEventListener('message',event=>{
		if(event.data=='REGISTER'){
			//First message sent by Service.connect() in app.js
			globalScope.pageChannel=event.ports[0];
			globalScope.pageChannel.postMessage('REGISTERED');
		}else{
			console.log(event);
			pageMessageHandler(event.data);
		}
	});
	async function pageMessageHandler({method,payload,msgId}){
		try{
			if(typeof public[method]=='function'){
				let ep="SERVICE."+method+"()";
				console.warn("APP => "+ep);
				try{
					var response=await public[method](payload);
				}catch(e){
					var err=e;
				}
				let data={msgId,response,err};
				console.log(ep+" => APP: ",data)
				try{
					globalScope.pageChannel.postMessage(data);
				}catch(cause){
					globalScope.logErrors(new Error("Failed to send response to app",{cause}),data);
				}
			}else{
				console.error("No such public endpoint:",method,payload,msgId);
			}
		}catch(cause){
			globalScope.logErrors("BUGBUG pageMessageHandler():",cause);
		}
	}






    globalScope.registration.addEventListener('updatefound', (evt) => {
        console.warn('Service Worker update found!',evt);
        //TODO: add broadcast to client
    });










  




	async function showNotification(){
		try{
			let obj=globalScope.prepareNotificationObj.apply(this,arguments);
			if(globalScope.pageChannel){
				await globalScope.pageChannel.postMessage({subject:'notification',payload:obj});
			}else{
				await globalScope.registration.showNotification(obj.title,obj);
			}
		}catch(e){
			console.error(e,arguments);
		}
	}
	 













	/**
	 * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event
	 * 
	 * @return void
	 * @async
	 */
	async function onInstall(event){
		try{
			console.warn('EVENT: install'+getDurration());

			var paralell=[];


			//If opted preload resources and populate the cache
			if(globalScope.config.primeCacheList){
				paralell.push(
					preloadResources(globalScope.config.primeCacheList)
						.catch(err=>{globalScope.logErrors("Failed to prime cache with:",list,err);})
				);
			}else{
				console.info("Not priming cache.")
			}

			//If opted setup a database
			if(globalScope.config.database){
				paralell.push(
					setupDatabase(globalScope.config.database)
						.catch(err=>{globalScope.logErrors("Failed to setup database:",err);})
				);
			}else{
				console.info("No IndexedDB defined in config, not setting one up.")
			}

			

			await Promise.all(paralell);
			
			console.warn('FINISHED: install'+getDurration());

			//Let this happen in the background
			setTimeout(checkSelfUpdate,3000);
		}catch(cause){
			globalScope.logErrors(new Error("'install' failed @ "+getDurration(),{cause}),globalScope);
		}
		return;
	};

	/**
	 * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event
	 * 
	 * @return void
	 * @async
	 */
	async function onActivate(event){
		try{
			console.warn('EVENT: activate'+getDurration());
			
			checkSelfUpdate();

			if(!globalScope.config.waitForServiceWorkerBoot){
				// If supported, enable navigation preloads. This means that while the service worker is booting up any
				// requests made of it are dispatched directly to the server which in turn implies that we may start a 
				// fetch for a resource which is actually cached, ie. we make the request "just in case"
				if (globalScope.registration.navigationPreload) {
					console.log("allowing server fetching while service worker boots")
					await globalScope.registration.navigationPreload.enable();
				}else{
					console.warn("preloading content is not supported, will wait for service worker boot to finish");
				}
			}else{
				console.warn("waiting for service worker to boot before performing fetching resources")
			}

		}catch(e){
			globalScope.logErrors(e);
		}
		// console.log('FINISHED: activate'+getDurration());
		return;
	}


	/**
	 * Intercepts fetch events and returns either a cached or newly fetched response, possibly a 404
	 * 
	 * @param <FetchEvent> event  An extened event with additional properties: .clientId, .preloadResponse, 
	 *                            .replacesCliendId, .resultingClientId, .request and method .respondWith()
	 *                                 https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent
	 * 
	 * @return Promise(<Response>)    Always resolves with a response object
	 * @async
	 */
	async function onFetch(event){
		try{
			var response,src;

			console.debug('FETCHING '+event.request.url+getDurration());
			checkSelfUpdate();
			
			//First we check the cache
			src="cache";
			response=await caches.match(event.request); 
			if(!response){ 
				//Then we ask the server...
				try{
					//If globalScope.config.waitForServiceWorkerBoot==false then we enabled navigationPreloading on the 'activate' event
					//which means that the fetch may already have been performed, otherwise we do so now...
					src="server-preload";
					response=await event.preloadResponse; //this resolves with undefined...
					if(!response){
						src="server"
						console.debug("Fetching from server now: "+event.request.url+getDurration());
						response=await fetch(event.request);
					}

					// Cache a copy of successfull responses. This happens async and we don't have to wait for it...
					cacheResponse(event.request,response.clone());
					
				}catch(e){
					//The only error which should be thrown here is if the request couldn't be made at 
					//all, eg. a network error. Since we need a response we create one
					response=new Response('Could not perform fetch. Possible network error. See console.', {
						status: 408
						,statusText:"Client error"
						,headers: { 'Content-Type': 'text/plain' }
						,url: event.request.url
					});
					throw e;
				}

			}

			//If we don't have a response now something has gone wrong!
			if(!response){
				throw new Error("BUGBUG: something wrong in code, we should have a response object by now");
			}

		}catch(e){
			globalScope.logErrors(e,getDurration(),{event,response,src});

			response=response|| new Response("Failed to fetch resource, unknown client-side error. See console", {
				status: 500
				,statusText: "Client error"
				,headers: { 'Content-Type': 'text/plain' }
				,url: event.request.url
			});
		}

		console.debug(`FINISHED: **${src}** fetch ${event.request.url}`+getDurration(),response);
		return response;
	};









	/**
	 * Store a response to the cache IF it's successful
	 * 
	 * @param object request             The event.request object from fetch-event
	 * @param <Response> clonedResponse  An already cloned response
	 * 
	 * @return void
	 * @async 
	 */
	async function cacheResponse(request,clonedResponse){
		try{
			if(clonedResponse && clonedResponse.status>=200 && clonedResponse.status<300){
				// responses may only be used once, so we store a clone to the cache
				let cache = await caches.open(globalScope.config.cacheName);
				await cache.put(request, clonedResponse);
				// console.log("Cached "+request.url+getDurration())
			}else{
				console.warn("Not caching response with status "+clonedResponse.status,clonedResponse);
			}

		}catch(e){
			globalScope.logErrors("Failed to cache response",{request,response:clonedResponse},e);
		}
		return;
		
	}


	async function preloadResources(list){
		try{
			console.log("priming cache with the following list of resources:",list)
			var cache=await caches.open(globalScope.config.cacheName);
			await cache.addAll(list);
		}catch(e){
			return Promise.reject(e)
		}
	}













	async function checkSelfUpdate(){
		try{
			var now=Date.now();
			if(!globalScope.lastUpdateCheck || globalScope.lastUpdateCheck < (now-globalScope.config.updateCheckInterval)){
				console.log("Checking for update of service worker now...");
				await globalScope.registration.update();
				globalScope.lastUpdateCheck=now;
				return true;
			}
		}catch(e){
			globalScope.lastUpdateCheck=(now-60*1000); 
				//^set the last check to be 1 minute ago, so we at least don't check right away again sssssss

			globalScope.logErrors(e);
		}
		return false;
	}




















	async function subscribeToMessages(){
		try {
			console.log("SUBSCRIBE"+getDurration());
			let options = {}
			let subscription = await globalScope.registration.pushManager.subscribe(options)
			console.log("Subscribed:"+getDurration(),subscription);
		} catch (e) {
			globalScope.logErrors(e);
		}

	}


	
	function showWindow(event){
	  	console.log('Background notification clicked!',event);
	  	setTimeout(()=>event.notification.close(),2000);

	  	// This looks to see if the current is already open and focuses if it is
		event.waitUntil(
		  	clients.matchAll({
			    type: "window"
			})
		  	.then((clientList) => {
		  		console.warn(clientList,clients);
			    for (const client of clientList) {
			    	if (client.url === '/' && 'focus' in client)
			        	return client.focus();
			    }
			    if (clients.openWindow)
			    	return clients.openWindow('/');
			})
		);
	}









	/* IndexedDB */

	

	async function setupDatabase(conf){
		try{
			conf=conf||globalScope.config.database;
			var promise=globalScope.exposedPromise(3000);

			var checkCreated=()=>{
			}

			if(globalScope.db){
				if(checkDbStructure(globalScope.db)){
					console.log("Database already setup and contains the right stores");
					promise.resolve();
				}else{
					promise.reject("Database is NOT in correct state");
				}
			}else{

				console.log(`Creating IDBDatabase '${conf.name}' v${conf.version}`);
				var request = indexedDB.open(conf.name,conf.version);
				
				request.onblocked=(event)=>{
					console.error('indexedDB.open.onblocked',event)
					promise.reject(event);
				};
				request.onerror=(event)=>{
					console.error('indexedDB.open.onerror',event)
					promise.reject(event);
				};

				
				//If the specified version of the database doesn't exist (which it shouldn't since it should then
				//have been stored to globalScope.db) the onupgradeneeded event will be fired. that event is fired
				//while request.transaction is still in "mode=versionchange", ie. the mode required to change stores...
				request.onupgradeneeded=(event)=>{
					try{
						let db=event.target.result;
						let transaction=request.transaction
						console.log("indexedDB.open.onupgradeneeded",{event,db,transaction}); 
						transaction.oncomplete=()=>{console.log("'versionchange' transaction completed",transaction)}
						transaction.onerror=(err)=>{globalScope.logErrors("'versionchange' transaction failed",err)}
						globalScope.dbStores=createAllObjectStores( db, conf.stores );
					}catch(cause){
						promise.reject(new Error("Failed during 'onupgradeneeded' event.",{cause}))
					}
				};


				request.onsuccess=(event)=>{
					console.log("indexedDB.open.onsuccess",event);
					//Since onupgradeneeded may not have fired because the db already existed we have to check to make
					//sure that it contains the tables we want
					globalScope.db=event.target.result;
					if(checkDbStructure(globalScope.db)){ //will log and reject promise if we're not setup right
						promise.resolve('Database open and verified to have correct stores');
					}else{
						promise.reject("Database open, but it doesn't contain the correct stores")
					}
					
				}
			}
		}catch(e){
			promise.reject(e);
		}

		return promise.catch(err=>{
			console.warn('indexedDB.open() request:',request);
			closeDatabase();
			return Promise.reject(err);
		});
	}


	function checkDbStructure(db){
		let details={
			created:Object.values(db.objectStoreNames)
			,configured:globalScope.config.database.stores
		};
		if(!details.created.length){
			console.error("None of the IDBObjectStores were created",details);

		}else if(details.created.length != details.configured.length){
			console.error("Not ALL of the IDBObjectStores were created",details);

		}else{
			//TODO: add check of internal structure
			return true;
		}
		return false;
	}


	function closeDatabase(){
		if(globalScope.db){
			console.log("Closing database...")
			globalScope.db.close();
		}			
		globalScope.db=null;
		globalScope.dbStores={};
	}

	async function deleteDatabase(){
		closeDatabase()
		console.log("Deleting database...")
		var promise=globalScope.exposedPromise();
		var req=indexedDB.deleteDatabase(globalScope.config.database.name);
		req.onsuccess=()=>{
			console.warn("Deleted IndexedDB");
			delete globalScope.db;
			promise.resolve(true);
		}
		req.onerror=promise.reject;
		req.onblocked=promise.reject;
		return promise.catch(evt=>{
			globalScope.logErrors("Failed to delete database",evt);
			promise.resolve(false);
		})
	}

	/**
	* Create all the IDBObjectStores we want on a IDBDatabase. 
	*
	* @param <IDBDatabase>     db
	* @param object            confs
	* 
	* 
	* @return object {name1:IDBObjectStores1, name2:IDBObjectStores...}) 
	*/
	function createAllObjectStores(db,confs){
		console.log("Creating "+confs.length+" IDBObjectStores...");
		var stores={};
		for(let s of confs){
			try{
				console.log(`Creating IDBObjectStore '${s.name}'`,s.options,s.schema);
				let store=db.createObjectStore(s.name, s.options);
				if(s.schema){
					for(let rule of s.schema){
						store[rule.method].apply(store,rule.args)
					}
				}
				stores[s.name]=store;
			}catch(cause){
				globalScope.logErrors(new Error(`Failed to create '${s.name}' IDBObjectStore`,{cause}));
			}
		}
		return stores;
	}
	
//This allows transaction to close...
	// function createAllObjectStoresSeq(db,confs){
	// 	confs=globalScope.copy(confs);
	// 	console.log("Creating "+confs.length+" IDBObjectStores...");
	// 	var stores={};
	// 	var promise=Promise.resolve();
	// 	while(confs.length){
	// 		let conf=confs.pop();
	// 		promise=promise.then(()=>createObjectStore(db,conf.name,conf.options,conf.schema)
	// 			.then(store=>{
	// 				stores[conf.name]=store;
	// 			}).catch(cause=>logErrors(new Error(`Failed to create '${conf.name}' IDBObjectStore`,{cause})))
	// 		);
	// 	}
	// 	return promise.then(()=>stores);
	// }



	// //Creates or opens an IDBObjectStore inside a IDBDatabase
	// function createObjectStore(db,name,options,schema){
	// 	try{
	// 		console.log(`Creating IDBObjectStore '${name}'`,options,schema);
	// 		let store=db.createObjectStore(name, options);
	// 		if(schema){
	// 			for(let rule of schema){
	// 				store[rule.method].apply(store,rule.args)
	// 			}
	// 		}
	// 		return new Promise((resolve,reject)=>{
	// 			store.transaction.oncomplete=()=>{
	// 				console.log(`Successfully created IDBObjectStore '${name}'`);
	// 				resolve(store);
	// 			};
	// 			store.transaction.onerror=reject;
	// 		});
	// 	}catch(e){
	// 		return Promise.reject(e);
	// 	}
	// }




	function getLast(type){
		return new Date('2022-09-01T10:51:27Z');
	}

	function setLast(type,timestamp){

	}

/*
{
	"status": "ok",
	"totalResults": 7401,
	-"articles": [
		-{
		-"source": {
			"id": null,
			"name": "seattlepi.com"
		},
		"author": "By MATT OTT, AP Business Writer",
		"title": "Fewer Americans file for jobless benefits last week",
		"description": "WASHINGTON (AP) —\nFewer Americans filed for unemployment benefits last week as the labor market continues to shine despite weakening elements of the U.S. economy.\nApplications for jobless aid for the week ending Aug. 27 fell by 5,000 to 232,000, the Labor Dep…",
		"url": "https://www.seattlepi.com/business/article/Fewer-Americans-file-for-jobless-benefits-last-17412312.php",
		"urlToImage": "https://www.seattlepi.com/img/pages/article/opengraph_default.png",
		"publishedAt": "2022-09-01T12:51:27Z",
		"content": "Fewer Americans filed for unemployment benefits last week as the labor market continues to shine despite weakening elements of the U.S. economy.Applications for jobless aid for the week ending Aug. 2… [+2996 chars]"
		},
		-{

*/


	function storeHeadline(headline){
		setLast('headline',headline.publishedAt);

	}

	async function fetchHeadlines(){
		try{
			var url=globalScope.config.googleNewsQuery+globalScope.config.googleNewsApiKey;
			var response=await fetch(url);
			var payload=await response.json();
			var headlines=payload.articles;
			for(let headline of headlines){
				delete headline.source;
				delete headline.content; //entire article
				headline.publishedAt=Math.floor(new Date(headline.publishedAt)); //unix timestamp
			}
			return headlines;
		}catch(cause){
			throw new Error("Failed to fetch headlines from "+url,{cause});
		}
	}

	/**
	 * Check for new headlines
	 * 
	 * @return array      Array of objects. All the new headlines (ie. those which havn't previously been stored)
	 * */
	async function checkNewHeadlines(){
		let last=getLast('headline');
		console.log("Checking for headlines newer than "+last);
		
		let headlines=await fetchHeadlines();
		
		let newHeadlines=[];
		for(let headline of headlines){
			if(headline.publishedAt>last){
				newHeadlines.push(headline);
				storeHeadline(headline);
			}
		}
		if(newHeadlines.length===1){
			let headline=newHeadlines[0];
			showNotification(headline.title,{body:headline.description});
		}else if(newHeadlines.length>1){
			let body=newHeadlines.map(headline=>" - "+headline.title).join('\n');
			showNotification("Found "+newHeadlines.length+" new headlines",{body});
		}else{
			console.debug("No new headlines found");
		}

		return newHeadlines;

	}



})(self)

	




